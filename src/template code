/*
ScaleToZero 
----- template code commented out BEGIN 

	try{
	
        int frameSize 	= ais.getFormat().getFrameSize(); 
	    int frameLength 	= (int) ais.getFrameLength();

	    // reset the AudioInputStream (mark goes to the start) 
	    ?? 

	    // create a byte array of the right size
    	    // recall the lecture OHP slides .. 
	    ?? 

	    // fill the byte array with the data of the AudioInputStream
	    ?? 

	    // Create an integer array, data, of the right size
	    // only reason to do this is enabling type float/double mixing calculations  
	    ??      data = new int[a.length/2];
	    
	
	     
	    // fill the integer array by combining two bytes of the
	    // byte array a into one integer - see lectures
	    ?? 
	    
	    for (int i=0; i<data.length; ++i) {
		/* First byte is HB (most significant digits) - coerce to 32-bit int */
		// HB =def sign_extend(a[2*i]) from 8 bit byte to 32 bit int 
		int HB = (int) a[2*i];
		/* Second byte is LB (least significant digits) - coerce to 32-bit int */
		// LB =def sign_extend(a[2*i+1]) from 8 bit byte to 32 bit int 
		int LB = (int) a[2*i+1];
		// note that data[i] =def sign_extend(HB.LB) 
		// | : Bool^32 x Bool^32 -----> Bool^32 where Bool = {0, 1} 
		data[i] =  HB << 8 | (LB & 0xff); 
 	    }
	    
	    ****Addiotanl bit - the max part *****
	    
	     // get the maximum amplitute
	    max=0;
	    for (int i=0; i<data.length; ++i) {
		max=Math.max(max,Math.abs(data[i]));
	    }
	    
	    if (max > 256*128 - 1) {
		System.out.println("Sound values are linearly scaled by " + (256.0*128.0-1)/max + 
             " because maximum amplitude is larger than upper boundary of allowed value range."); 
		for (int i=0; i<data.length; ++i) {
		    data[i] = (int) (data[i]*(256.0*128.0-1)/max);
		}
            }
	    
	    // scale data linearly by a factor of 3/4  
	    // **** NB this is the only part of scaleToZero that is not already part of
	    // echo effect !!!! ****
	    ?? 

	    // convert the integer array to a byte array 
	   ?? for (int i=0; i<data.length; ++i) {
		a[2*i] 	  = (byte)  ((data[i] >> 8) & 0xff);
		a[2*i+1]  = (byte)         (data[i] & 0xff);
	    }


	} catch(Exception e){
	    System.out.println("Something went wrong");
	    e.printStackTrace();
	}

 ----- template code commented out END */

	// create a new AudioInputStream out of the the byteArray
	// and return it.
	
	
	**********addNote************
	
	/* ----- template code commented out BEGIN 

      try { 
  
	// number of frames for the note of noteLengthInMilliseconds
 	float frameRate = ais.getFormat().getFrameRate();
	int noteLengthInFrames = ??
	int noteLengthInBytes  = ??
	int noteLengthInInts   = ??

	a   = new byte[noteLengthInBytes];
	data = new int[noteLengthInInts];
			
        // create the note as a data array of integer samples 
	// each sample value data[i] is calculated using 
	// the time t at which data[i] is played

	for (int i=0; i<noteLengthInInts; i+=2) {
	    	// what is the time to play one frame?
		// BEFORE "frame" data[i]data[i+1] plays, how many frames are there? 
		// hence compute t in terms of i 
		// double t = ?? 
		data[i]   = ?? (one line of code) 
		?? one more line of code here
	}

	// copy the int data[i] array into byte a[i] array 			   
	?? 

	} catch(Exception e){
	    System.out.println("Something went wrong");
	    e.printStackTrace();
	}

 ----- template code commented out END */
	
	